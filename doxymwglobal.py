import sys
from enum import Enum

#Configuration options
#These are assumed static at runtime
#All of these must be defined, sane, and not empty unless otherwise stated
config = {}

#Doxygen related path info
config["doxygen_binaryPath"] = "C:/Program Files/doxygen/bin"
config["doxygen_configPath"] = "./DoxyfileTest" 
config["doxygen_tmpPath"] = "./tmp" 

#MediaWiki stuff
config["mediaWiki_docsPrefix"] = "DoxyMWBot_DoxygenDocs"
config["mediaWiki_docsCategory"] = "DoxyMWBot_DoxygenDocs" #The category name to use for the doxygen docs

#Certain MediaWiki settings an admin would have to turn on
#Requires a custom namespace
#NOT IMPLEMENTED
#config["mediaWiki_useNamespace"] = False
#config["mediaWiki_namespaceName"] = ""

#Invalid characters (like < and > for C# generics) will be substituted with some other char
#Unrestricting display title allows us to change the chars and resubstitute them back in with a {{DISPLAYTITLE:_}} magic word
#Requires $wgRestrictDisplayTitle to be False
config["mediaWiki_useFullDisplayTitle"] = True

#If you want to be able to add content to your pages, you probably want to enable this option
#This creates an extra page for every doxygen documentation page. All links will point to this blank counterpart page instead of the original.
#The new blank page is set up with a redirect to redirect to the original content.
#HOWEVER, you can take advantage of this by removing the redirect, adding your own content, and transcluding the original page on this page.
#More help is provided on the wiki with links from the autogenerated documentation pages
config["mediaWiki_setupTransclusions"] = True
config["mediaWiki_transclusionCategory"] = "DoxyMWBot_TransclusionDocs"
config["mediaWiki_transclusionPrefix"] = "" #Prefix of transclusion, can be empty
config["mediaWiki_transclusionExternalCategory"] = "CodingDocs" #Category to add all these pages to, can be no category (to turn off)

#Program default options
#Change at run time
option = {}
option["command"] = None
option["interactive"] = False
option["debug"] = None
option["warnIsError"] = False
class msgType(Enum):
    error = 3
    warning = 2
    info = 1
    debug = 0
option["printLevel"] = msgType.warning

#Utility functions    
def msg(type, str, usage=False, **kwargs):
    #Determine all variables
    printStr = None
    isError = False
    if type == msgType.error:
        printStr = "ERROR: " + str
        isError = True
    elif type == msgType.warning:
        printStr = "WARNING: " + str
        if option["warnIsError"]:
            isError = True
    elif type == msgType.info:
        printStr = "INFO: " + str
    elif type == msgType.debug:
        printStr = "DEBUG: " + str
    else:
        msg(msgType.error, "Invalid message type")
        return
    
    #Print everything if we're >= printLevel 
    if type.value >= option["printLevel"].value:
        print(printStr, **kwargs)
    
    if usage:
        print(getUsage())
    
    if isError:
        sys.exit(type.value-1) #1 for warning, 2 for error
        
def getUsage():
    return (
        "\nUSAGE: python doxymw.py <command> [<opts>]"
        "\n"
        "\n<command> can be:"
        "\n  update   update some wiki with documentation"
        "\n  cleanup  delete all the autogenerated documentation on a wiki"
        "\n"
        "\n<opts> can be:"
        "\n  -i,   --interactive   Interactive mode"
        "\n  -d:_, --debug:_       Debug where _ is in [doxygen, unsafeUpdate]"
        "\n  -p:_, --printLevel:_  Show msgs with severity _ in [error, warning, info, or debug]"
        "\n  -w,   --warnIsError   If warnings cause program to stop"
        "\n  -h,   --help          Prints help message")

        
def printHelp():
    print(getUsage())
    